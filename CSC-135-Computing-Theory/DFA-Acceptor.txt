4. DFA-Acceptor - Consider the following DFA which may start with zero or more 1s which must be followed by a 01 which may be followed by any string. The DFA has the following transitions:
Q0 is the start state. P is a sink state for transitions that lead to a fail state (string is not accepted if it transitions to this state P). F = {Q2} is the final state.
Write a DFA that returns #t (True in Scheme) if it accepts a string and returns #f (False in Scheme) if it does not accept the string.
Q0 on 1 transitions to Q0
Q0 on 0 transitions to Q1
Q1 on 1 transitions to Q2
Q1 on 0 transitions to P
Q2 on 0 and 1 transitions to Q1.
The DFA stops with a Boolean return value of #f on reaching P and returns #t on reaching Q2 at the end of the string. Assume the string is represented as a list of 0s and

1s. Write functions corresponding to Q0, Q1, Q2 and P that returns functions. For
example the function Q0 when called represents the state it transitions to: (Q0 0)
returns the function Q1. (Q0 1) returns the function Q0.
The DFA Acceptor is called as follows:
(DFA-Acceptor <list of alphabets in string to be accepted> <start-state> (<list of final
states>) <sink-state>)
(DFA-Acceptor ‘(1 1 0 1 0) Q0 (Q2) P) returns #t
And
(DFA-Acceptor ‘(1 0 0) Q0 (Q2) P) returns #f


#lang racket

(define (Q0 x) (if(= x 0) Q1 Q0))
(define (Q1 x) (if(= x 1) Q2 P))
(define (Q2 x) Q2)
(define (P x) P)

(define (DFA-Acceptor x y z r)
  (if(null? x) ( if(equal? (member y (map eval z)) (map eval z))#t #f)
     (cond ((eq? y r) #f)
       (else (DFA-Acceptor (cdr x) (y (car x)) z r)))))
       
;test
;(DFA-Acceptor '(1 1 0 1 0) Q0 '(Q2) P)
;(DFA-Acceptor '(1 0 0 ) Q0 '(Q2) P)
